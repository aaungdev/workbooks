Idea Name
AMG collaboration sites record retention management

Brief Description
Alternative Modelling Group will move from having no shared drive record retention review process to implementing a review process by creating procedures to regularly review and move aged records and bulk files into Documentum and delete unneeded files to align with enterprise policy. Benefits include minimizing operational risk and saving 80 hours per year.

Issue (current state)
To comply with the bank record retention policy, aged files must be moved to Documentum from collaboration sites. Without procedures and an automation tool, aged files are not regularly reviewed or moved, leading to risk of noncompliance over time.

Solution (future/target state)
Use GRA data infrastructure strategy team’s automation tool to move records to Documentum for retention and delete non-records. Update procedures to ensure quarterly review.

Benefits
Minimizes operational risk, removes manual effort to identify aged documents, improves space management to reduce storage costs, and avoids production disruption. Expected capacity savings: 80 hours per year.


=LET(
  k, --TEXT(Model Capacity Aggregate!K3,"0"),
  d, --TEXT(STATIC!D:D,"0"),
  LOOKUP(2, 1/(d=k), STATIC!A:A)
)
=XLOOKUP(Model Capacity Aggregate!K3, STATIC!D:D, INDEX(STATIC!A:A,0))

=INDEX(STATIC!A:A, MATCH(Model Capacity Aggregate!K3, STATIC!D:D, 0))


=IFERROR(INDEX(STATIC!A:A, MATCH(Model Capacity Aggregate!K3, STATIC!D:D, 0)), "")
=SUM(SUMIFS('Capacity Plan'!W:W,
            'Capacity Plan'!F:F,E3,
            'Capacity Plan'!G:G,"*2025*",
            'Capacity Plan'!E:E,{"*BAU*","*RAI*","*OMR*"}))
Category:
Indicate whether the repository is a model, tool, or other type.
# Your Jira credentials and base URL — replace these with your real values
ENV_VALUES = {
    "JIRA_API_TOKEN": "your_api_token_here",
    "JIRA_BASE_URL": "https://yourcompany.atlassian.net",
}

class JiraQuerier:
    _jira_api = None  # Class variable to hold Jira client instance

    @classmethod
    def setup_jira_api(cls):
        # Initialize Jira API client if not already done
        if cls._jira_api is None:
            cls._jira_api = JIRA(
                token_auth=ENV_VALUES["JIRA_API_TOKEN"],  # Use API token for authentication
                server=ENV_VALUES["JIRA_BASE_URL"],       # Jira instance URL
                kerberos=True,                            # Enable Kerberos authentication (per your original code)
                options={"verify": False},                # Disable SSL verification (use with caution)
            )

    @classmethod
    def get_components_by_project(cls, project_key):
        cls.setup_jira_api()  # Make sure Jira client is ready

        jql = f'project = {project_key}'  # Jira Query Language string to get all issues for the project
        issues = cls._jira_api.search_issues(jql, maxResults=50)  # Fetch up to 50 issues

        result = {}  # Dictionary to store results: issue_key -> list of component names

        for issue in issues:
            comps = issue.fields.components  # Access the components field from issue
            # Extract component names if any, else empty list
            comp_names = [c.name for c in comps] if comps else []
            result[issue.key] = comp_names  # Store component names keyed by issue key

        return result  # Return the dictionary of issue components

# Main block runs when script is executed directly
if __name__ == "__main__":
    components = JiraQuerier.get_components_by_project("GRAAMG")  # Query project GRAAMG

    # Print each issue's key and its Component(s)
    for issue_key, comp_list in components.items():
        print(f"{issue_key}: Component(s) = {comp_list}")